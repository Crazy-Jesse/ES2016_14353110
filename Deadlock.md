# Lab4.Deadlock dol.md


##1.截图
![](https://github.com/Crazy-Jesse/ES2016_14353110/blob/master/DOL/lab4/DEADLOCK.jpg)
##2.死锁的四个必要条件：
    1）互斥条件：一个资源每次只能被一个进程使用。
	2）请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放
	3）不剥夺条件：进程已获得的资源，在未使用完之前，不能强行剥夺
	4）循环等待条件：若干进程之间形成一种头尾相接的循环等待资源关系。
##3.产生死锁的解释
        A与B均是synchronized,当它用来修饰一个方法或者一个代码块的时候，能够保证在同一时刻最多只有一个线程执行该段代码。
        当一个线程访问object的一个synchronized同步代码块或同步方法时，其他线程对object中所有其它synchronized同步代码块或同步方法的访问将被阻塞。
    满足了死锁的1)2)3)的条件
	    此后是利用了一个线程 在主函数的时间轴中当开始之后就将线程插入调度队列里跑run里面的代码。然后代码中A需要调用B中的锁，而B需要A中的锁。这样来实现死锁的第四个条件。


